{
  "Title": "Action and Func in C#",
  "Id": 2,
  "BlogText": "Action and Func delegates are used in our .NET code more often than we might think. They are not meant to confuse us as much as the IntelliSense function signature preview window might lead us to believe. So let's learn more about how and when to use these built-in delegates in this article.\r\nAction and Func Delegates\r\nAction and Func are built-in generic delegates in the .NET System namespace.These delegates are extremely flexible and will be useful in most situations where we might need to use delegates in our code.As a reminder, delegates are types that reference or encapsulate a method with a defined set of parameters and return type.Informally speaking delegates allow us to \"variable-ize\" functions and pass them as parameters.\r\nAction Delegates\r\nAction<> is a generic delegate that returns no value and can have a maximum of 16 parameters.The types in the<> are the types of the parameters of the function we can assign this Action to.\r\nLet's take a look at how we can create a simple instance:\r\nvoid ReportProfits(double grossSales, double totalExpenses)\r\n{\r\n    Console.WriteLine(grossSales - totalExpenses);\r\n}\r\n\r\nvar reporter = new Action<double, double>(ReportProfits);\r\n\r\nvar aggregatedSales = 1000000.00;\r\nvar aggregatedExpenses = 12340.00;\r\n\r\nreporter(aggregatedSales, aggregatedExpenses);\r\nWe can assign lambda expressions and anonymous functions to Actions. This is what makes Actions and Funcs such useful tools in a developer's toolbox. This affords a developer the ability to write syntactically expressive and readable code.\r\n\r\nLet's take a look at how we can assign a lambda to an Action this way:\r\nvar aggregatedSales = 1000000.00;\r\nvar aggregatedExpenses = 12340.00;\r\n\r\nAction<double, double> reporter = (grossSales, totalExpenses) => Console.WriteLine(grossSales - totalExpenses);\r\n\r\nreporter(aggregatedSales, aggregatedExpenses);\r\nNow let's do the same with an anonymous function:\r\nvar aggregatedSales = 1000000.00;\r\nvar aggregatedExpenses = 12340.00;\r\n\r\nAction<double, double> reporter\r\n    = delegate (double grossSales, double totalExpenses) { Console.WriteLine(grossSales - totalExpenses); };\r\n\r\nreporter(aggregatedSales, aggregatedExpenses);\r\nFunction Delegates\r\nFunc<> is a generic delegate that must return a value and can have a maximum of 16 parameters.The types in the<> are the types of the parameters of the function we can assign this Func to. It's very important to note that the return value of the Func is the last type in the <> list.\r\nGenerically speaking we can view a Func's signature like this:\r\nFunc<T1, T2, T3, ..., TResult> myFunc;\r\nLet 's take a look at how we can create a Func:\r\n\r\ndouble CalculateProfits(double grossSales, double totalExpenses)\r\n{\r\n    return grossSales - totalExpenses;\r\n}\r\n\r\nvar reporter = new Func<double, double, double>(CalculateProfits);\r\n\r\nvar aggregatedSales = 160540.43;\r\nvar aggregatedExpenses = 4342.99;\r\n\r\nConsole.WriteLine(reporter(aggregatedSales, aggregatedExpenses));\r\nSimilar to Actions, we can assign lambdas and anonymous functions to Funcs:\r\nvar carSales = 56489.02;\r\nvar truckSales = 1515868.44;\r\n\r\nFunc<double, double, double> salesAggregator = (a, b) => a + b;\r\n\r\nsalesAggregator(carSales, truckSales);\r\n\r\n\/\/ Or\r\n\r\nFunc<double, double, double> salesAggregator = delegate (double a, double b) { return a + b; };\r\n\r\nsalesAggregator(carSales, truckSales);\r\nAlternate Syntax for Delegates\r\nDelegates can be assigned functions to encapsulate by just passing the function name rather than using the new keyword.Let's consider a rewrite of a previous example:\r\n\/\/ assigning delegate using method name\r\nvar reporter = ReportProfits;\r\n\r\n\/\/ previously\r\n\/\/var reporter = new Action<double, double>(ReportProfits);\r\nSecondly, the Invoke() function is an alternative for calling delegates. This is the same as just using () after the delegates name as we have already seen used. Using the Invoke() function may be preferable so that we may offer the reader of our code a sure signal that a delegate is being called. Invoke will take in the parameters the delegate requires:\r\nsalesAggregator.Invoke(deparmentASales, departmentBSales); \/\/ Same as salesAggregator(deparmentASales, departmentBSales)\r\nWhy Use Action and Func?\r\nWe can creatively use these delegates to write clean expressive code. More importantly, we can achieve more advanced method calling. For example, passing a delegate to a function allows the user to customize the function's behavior. Consequently, this allows a method to run code that it does not know of yet while assuring the method's parameters and return type.\r\n\r\nLet's consider a real-world example using LINQ. Using LINQ's Where() method we can selectively filter a Collection based on a Func<TCollection, bool> passed in. This effectively performs a SQL SELECT operation on our Collection for all items that return true when evaluated against the Func.\r\n\r\nLet's break this down further in this example:\r\ninterface IFruit\r\n{\r\n    bool isCitrus { get; set; }\r\n}\r\n\r\nvar fruits = new List<IFruit>() { new Apple(), new Banana(), new Orange() };\r\n\r\n\/\/ in this case Where() signature is: Where(Func<IFruit, bool>)\r\nvar allCitrusFruits = fruits.Where(fruit => fruit.isCitrus); \/\/ allCitrusFruits should now only be a collection containing 'Orange'\r\n",
  "Images": [],
  "BlogPostPreview": {
    "Title": "Action and Func in C#",
    "ImageFilePath": "../Images/WhatTheFunc.png",
    "BlogPostPreviewText": "Action and Func are built-in delegate types in C#! They are extremely useful for creating flexible, advanced methoding, and sytactically readable code. You might have already used Action and Func without realizing. If you have used LINQ before you probably familiar with how powerful these delegate types can be."
  }
}